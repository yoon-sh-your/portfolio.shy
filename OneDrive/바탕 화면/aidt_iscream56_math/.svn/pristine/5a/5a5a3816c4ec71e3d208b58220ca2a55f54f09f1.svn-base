runAfterAppReady(function () {
    const showArcDiv = document.querySelector('.show_arc');
    const showArcInstance = new showArc(showArcDiv);

    // ë²„íŠ¼ í™œì„±í™” ê·œì¹™ ì •ì˜
    defineButtonClassRules([
        {
            selector: ".show_arc",
            test: (el) => {
                // correction ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const correction = el.getAttribute('data-correction');
                // correction ì†ì„±ì´ ì—†ê±°ë‚˜ ë¹ˆ ë°°ì—´ì´ë©´ false
                return !correction || correction === '[]' ? false : true;
            },
            setClass: [
                { target: ".btnReset", class: "active" },
                { target: ".btnCheck", class: "active" }
            ]
        }
    ]);

    window.resetCustom = function () {
        const activePage = pagenation.activePage;
        if (activePage) {
            const activeShowArc = activePage.querySelector('.show_arc');

            // ëª¨ë“  ì„  ì œê±°
            const lines = activeShowArc.querySelectorAll('.click-line');
            lines.forEach(line => line.remove());

            // ëª¨ë“  ì  ì œê±°
            const points = activeShowArc.querySelectorAll('.click-point');
            points.forEach(point => point.remove());

            // data-correction ì†ì„± ì œê±°
            activeShowArc.removeAttribute('data-correction');

            // data-connection ì†ì„± ì´ˆê¸°í™”
            activeShowArc.setAttribute('data-connection', JSON.stringify([]));

            // ì¸ìŠ¤í„´ìŠ¤ì˜ ì •ë³´ ì œê±°
            showArcInstance.reset();

            // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
            window.forceWatchEvaluation();
        }
    }

    window.getCustomTargets = function (page) {
        return $(page).find(".show_arc");
    };

    let dataAnswers;
    // ì»¤ìŠ¤í…€ ì •ë‹µ ì¡°ê±´
    window.customCheckCondition = function (el) {
        // data-correction ì†ì„±ì´ 'true'ì´ë©´ ì •ë‹µ ì²˜ë¦¬
        console.log(el);
        const correction = el.getAttribute('data-correction');
        dataAnswers = el.getAttribute('data-single-answer');
        if (correction === 'true') {
            return true;
        }

        // data-correction ì†ì„±ì´ ì—†ê±°ë‚˜ 'false'ì´ë©´ ì˜¤ë‹µ ì²˜ë¦¬
        return false;
    };

    // ë‘ ë²ˆì§¸ ì˜¤ë‹µ ì‹œ
    window.onIncorrectTwiceCustom = function () {
        alert("ğŸš¨ ì •ë‹µ ê³µê°œë©ë‹ˆë‹¤!");

        showArcInstance.reset();

        // ì •ë‹µ ì„  ê·¸ë¦¬ê¸°
        // console.log("dataAnswers", dataAnswers);
        // dataAnswersParsed = JSON.parse(dataAnswers);

        const forceClickArr = [1, 6, 6, 11];
        forceClickArr.forEach((value, index) => {
            showArcInstance.forceClick(value);
            // console.log(value);
        });
    };
});

const colors = ['#F00', '#3B71FE', '#222'];

class showArc {
    constructor(showArcDiv) {
        this.showArcDiv = showArcDiv;
        this.svg = showArcDiv.querySelector('#showArcSvg');
        this.NS = "http://www.w3.org/2000/svg";

        this.svgHeight = Number(this.svg.getAttribute('height'));
        this.svgWidth = Number(this.svg.getAttribute('width'));

        this.barRect = this.svg.querySelector('rect.bar');
        this.barWidth = Number(this.barRect.getAttribute('width'));
        this.barHeight = Number(this.barRect.getAttribute('height'));
        this.barStartX = Number(this.barRect.getAttribute('x'));
        this.barStartY = Number(this.barRect.getAttribute('y'));

        this.sectionPx = this.barWidth / 15;

        // // ê¸°ë³¸ ì„¤ì • ê°’ ë¡œê·¸
        // console.log("this.svgHeight", this.svgHeight);
        // console.log("this.svgWidth", this.svgWidth);
        // console.log("this.barWidth", this.barWidth);
        // console.log("this.barHeight", this.barHeight);
        // console.log("this.barStartX", this.barStartX);
        // console.log("this.barStartY", this.barStartY);

        // // ê³„ì‚° ë¡œê·¸
        // console.log("this.barWidth / 15", this.barWidth / 15); // 70

        // ìƒíƒœ ê´€ë¦¬
        this.state = {
            arcs: [],
        };

        this.selectedPoints = [];
        this.selectedtwoPoints = [];
        this.selectedClickPoints = [];

        this.init();
    };

    init() {
        console.log('init');

        // ì´ˆê¸° ì ë“¤ ìƒì„±
        this.createDiameterPoints();
    }

    createDiameterPoints() {
        for (let i = 0; i < 11; i++) {
            const x = this.barStartX + (this.sectionPx * 5) + (i * this.sectionPx);
            const y = this.barStartY;

            const clickArea = document.createElementNS(this.NS, "circle");
            clickArea.setAttribute("cx", x);
            clickArea.setAttribute("cy", y);
            clickArea.setAttribute("r", "16");
            clickArea.setAttribute("class", "diameter-point-area");
            clickArea.setAttribute("data-selected", "false");
            clickArea.setAttribute("data-order", `${i + 1}`);

            const point = document.createElementNS(this.NS, "circle");
            point.setAttribute("cx", x);
            point.setAttribute("cy", y);
            point.setAttribute("r", "16");
            point.setAttribute("class", "diameter-point");
            point.setAttribute("data-selected", "false");

            const handleClick = (e) => {
                e.stopPropagation();

                clickArea.setAttribute("data-selected", "true");
                point.setAttribute("data-selected", "true");

                this.selectedPoints.push({ x, y });
                this.selectedtwoPoints.push({ clickArea, point });

                this.drawPoint(x, y);

                if (this.selectedPoints.length === 2) {
                    const [p1, p2] = this.selectedPoints;

                    const existingLine = this.state.arcs.find(arc => {
                        const match1 = arc.x1 === p1.x && arc.y1 === p1.y && arc.x2 === p2.x && arc.y2 === p2.y;
                        const match2 = arc.x1 === p2.x && arc.y1 === p2.y && arc.x2 === p1.x && arc.y2 === p1.y;
                        return match1 || match2;
                    });

                    if (existingLine) {
                        console.log('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì„ ì…ë‹ˆë‹¤!');

                        this.svg.querySelector(`.diameter-point-area[cx="${p1.x}"][cy="${p1.y}"]`)?.setAttribute('data-selected', 'false');
                        this.svg.querySelector(`.diameter-point[cx="${p1.x}"][cy="${p1.y}"]`)?.setAttribute('data-selected', 'false');
                        this.svg.querySelector(`.diameter-point-area[cx="${p2.x}"][cy="${p2.y}"]`)?.setAttribute('data-selected', 'false');
                        this.svg.querySelector(`.diameter-point[cx="${p2.x}"][cy="${p2.y}"]`)?.setAttribute('data-selected', 'false');

                        for(const arc of this.state.arcs){
                            const equalArc = (
                                arc.x1 === p1.x && arc.x2 === p2.x || 
                                arc.x2 === p1.x && arc.x1 === p2.x
                            );
                            console.log('equalArc', equalArc);
                            if(equalArc){
                                this.svg.removeChild(arc.path);
                                this.state.arcs.pop(arc);
                                console.log(this.state.arcs);
                            }
                        }
                        for (const sCPoint of this.selectedClickPoints) {
                            console.log('sCPoint', sCPoint);
                            console.log('sCPoint parentNode', sCPoint.parentNode);
                            this.svg.removeChild(sCPoint);
                            // this.state.twoPoint.pop(sCPoint);

                            const existingPoints = Array.from(this.svg.getElementsByClassName('click-point'));
                            console.log("existingPoints.length", existingPoints.length)
                            for(const exPoint of existingPoints){
                                const exCx = exPoint.getAttribute("cx");
                                const spCx = sCPoint.getAttribute("cx");
                                if(exCx === spCx) {
                                    console.log('exPoint', exPoint);
                                    if(exPoint) {
                                        this.svg.removeChild(exPoint);
                                    }
                                    break;
                                }
                            }
                        }
                    } else {
                        console.log('í˜¸ ê·¸ë¦¬ê¸°');
                        this.drawArc();
                    }

                    this.selectedPoints = [];
                    this.selectedtwoPoints = [];
                    this.selectedClickPoints = [];
                }

                console.log('this.state', this.state);
                this.update();
            };

            clickArea.addEventListener('click', handleClick);
            point.addEventListener('click', handleClick);

            this.svg.appendChild(clickArea);
            this.svg.appendChild(point);
        }
    }

    drawPoint(x, y) {
        const existingPoints = Array.from(this.svg.getElementsByClassName('click-point'));

        const point = document.createElementNS(this.NS, "circle");
        point.setAttribute("cx", x);
        point.setAttribute("cy", y);
        point.setAttribute("r", "6");
        point.setAttribute("class", "click-point");
        // point.setAttribute('data-id', Math.random());

        this.svg.appendChild(point);

        this.selectedClickPoints.push(point);
        console.log('this.selectedClickPoints', this.selectedClickPoints);

        // if(this.selectedClickPoints.length === 2){
        //     this.selectedClickPoints = [];
        //     console.log('this.selectedClickPoints clear', this.selectedClickPoints);
        // }
    }

    // remove2point(twoPoint) {
    //     // ë‘ ì  ì§€ìš°ê¸°
    //     // ì¡´ì¬í•˜ëŠ” ë¼ì¸ê³¼ ì ë“¤
    //     const existingPoints = Array.from(this.svg.getElementsByClassName('click-point'));
    //     // ë‘ ì  ì‚­ì œ
    //     for (const point of twoPoint) {
    //         const { x, y } = point;
    
    //         // 1. ì  ì‚­ì œ
    //         for (const exPoint of existingPoints) {
    //             const exCX = parseFloat(exPoint.getAttribute('cx'));
    //             const exCY = parseFloat(exPoint.getAttribute('cy'));
    
    //             if (exCX === x && exCY === y) {
    //                 // ì  ì‚­ì œ
    //                 this.svg.removeChild(exPoint);
    //             }
    //         }
    //     }
    // }

    // removeArc() {
    //     const existingArcs = Array.from(this.svg.getElementsByClassName('click-line'));

    //     for (const point of this.selectedPoints) {
    //         const { x, y } = point;

    //         for (const arc of existingArcs) {
    //             const x1 = parseFloat(arc.getAttribute('data-x1'));
    //             const y1 = parseFloat(arc.getAttribute('data-y1'));
    //             const x2 = parseFloat(arc.getAttribute('data-x2'));
    //             const y2 = parseFloat(arc.getAttribute('data-y2'));

    //             const isConnected = (x1 === x && y1 === y) || (x2 === x && y2 === y);

    //             if (isConnected) {
    //                 if (this.svg.contains(arc)) {
    //                     this.svg.removeChild(arc);
    //                 }
    //                 this.state.arcs = this.state.arcs.filter(a =>
    //                     !((a.x1 === x1 && a.y1 === y1 && a.x2 === x2 && a.y2 === y2) ||
    //                         (a.x1 === x2 && a.y1 === y2 && a.x2 === x1 && a.y2 === y1))
    //                 );
    //             }
    //         }
    //     }
    // }

    drawArc() {
        const [p1, p2] = this.selectedPoints;

        const cx1 = p1.x + (p2.x - p1.x) * 0.25;
        const cy1 = p1.y - (Math.abs(p2.x - p1.x) / 5.6) - 16;
        const cx2 = p1.x + (p2.x - p1.x) * 0.75;
        const cy2 = p2.y - (Math.abs(p2.x - p1.x) / 5.6) - 16;

        const path = document.createElementNS(this.NS, "path");
        const d = `M${p1.x} ${p1.y} C${cx1} ${cy1} ${cx2} ${cy2} ${p2.x} ${p2.y}`;

        path.setAttribute("d", d);
        path.setAttribute("stroke", colors[this.state.arcs.length % colors.length]);
        path.setAttribute("stroke-width", "2");
        path.setAttribute("stroke-dasharray", "4 4");
        path.setAttribute("fill", "transparent");
        path.setAttribute("class", "click-line");
        path.setAttribute("data-x1", p1.x);
        path.setAttribute("data-x2", p2.x);
        path.setAttribute("data-y1", p1.y);
        path.setAttribute("data-y2", p2.y);

        this.svg.appendChild(path);

        this.state.arcs.push({ x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, area: Math.round(Math.abs(p2.x - p1.x) / this.sectionPx), path: path});
        console.log('this.state.arcs', this.state.arcs);
    }

    update() {
        this.showArcDiv.removeAttribute('data-correction');
        this.showArcDiv.setAttribute('data-connection', JSON.stringify([]));
        // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
        window.forceWatchEvaluation();

        const areas = [];
        for(const arc of this.state.arcs) {
            areas.push(arc.area);
        }

        // connection ë°ì´í„° ì—…ë°ì´íŠ¸
        this.showArcDiv.setAttribute('data-connection', JSON.stringify(areas));

        // correction ë°ì´í„° ì²´í¬
        const answerData = this.showArcDiv.getAttribute('data-single-answer');

        console.log('í˜„ì¬ ì˜ì—­:', areas);
        console.log('ì •ë‹µ ë°ì´í„°:', answerData);

        if (answerData) {
            try {
                // data-single-answer ê°’ì„ JSONìœ¼ë¡œ íŒŒì‹±
                const answers = JSON.parse(answerData);

                console.log('íŒŒì‹±ëœ ì •ë‹µ:', answers);

                // ë°°ì—´ ê¸¸ì´ê°€ ë‹¤ë¥´ë©´ false
                if (areas.length !== answers.length) {
                    console.log('ë°°ì—´ ê¸¸ì´ ë¶ˆì¼ì¹˜:', areas.length, answers.length);
                    this.showArcDiv.setAttribute('data-correction', 'false');
                    // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
                    window.forceWatchEvaluation();
                    return;
                }

                // ê°’ë§Œ ë¹„êµí•˜ë ¤ë©´ ë‘ ë°°ì—´ì„ ì •ë ¬ í›„ ë¹„êµ
                const sortedPercentages = [...areas].sort((a, b) => a - b);
                const sortedAnswers = [...answers].sort((a, b) => a - b);

                // ë°°ì—´ ê°’ ë¹„êµ
                let isCorrect = sortedPercentages.every((val, index) => parseInt(val) === parseInt(sortedAnswers[index]));

                console.log('ì •ë‹µ ì—¬ë¶€:', isCorrect);
                if (isCorrect) {
                    this.showArcDiv.setAttribute('data-correction', 'true');
                } else {
                    this.showArcDiv.setAttribute('data-correction', 'false');
                }
                // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
                window.forceWatchEvaluation();
            } catch (e) {
                console.error('JSON íŒŒì‹± ì—ëŸ¬:', e);
                this.showArcDiv.setAttribute('data-correction', 'false');
                // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
                window.forceWatchEvaluation();
            }
        }
    }

    reset() {
        // ëª¨ë“  ì„ , ì , í…ìŠ¤íŠ¸ ì œê±°
        const arcs = this.svg.getElementsByClassName('click-line');
        const points = this.svg.getElementsByClassName('click-point');

        while (arcs.length > 0) arcs[0].remove();
        while (points.length > 0) points[0].remove();

        // ìƒíƒœ ì´ˆê¸°í™”
        this.state.arcs = [];

        // data-selected=true ì œê±°
        const selectedElements = this.svg.querySelectorAll('[data-selected="true"]');
        selectedElements.forEach(el => {
            el.setAttribute('data-selected', 'false');
        });

        // data-correction ì†ì„± ì œê±°
        this.showArcDiv.removeAttribute('data-correction');

        console.log('showArcInstans ë¦¬ì…‹ ë¨');
    }

    // í´ë¦­ ì´ë²¤íŠ¸ ë°œìƒ ì‹œí‚¤ê¸°
    forceClick(dataOrder) {
        // í´ë¦­ ì´ë²¤íŠ¸ ë°œìƒì‹œì¼œ ì„  ì¶”ê°€
        const clickPoints = document.querySelectorAll(`circle[data-order="${dataOrder}"]`);
        if (clickPoints) {
            clickPoints.forEach((value) => {
                // 'click' ì´ë²¤íŠ¸ë¥¼ ê°•ì œë¡œ ë°œìƒì‹œí‚´
                const clickEvent = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: window
                });
                value.dispatchEvent(clickEvent);
            });
        } else {
            console.warn(`circle[data-order="${dataOrder}"]ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        }
    }
}