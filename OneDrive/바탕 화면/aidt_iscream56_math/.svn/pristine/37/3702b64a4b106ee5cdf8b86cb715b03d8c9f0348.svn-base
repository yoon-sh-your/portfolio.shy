runAfterAppReady(function () {
    const activePage = pagenation.activePage;
    const pageClassList =  pagenation.activePage.classList;
    console.log('activePage', activePage);
    console.log('pageClassList', pageClassList);
    
    // if (element.classList.contains('page_3')) {
    
        const showArcDiv = document.querySelector('.show_arc');
        const showArcInstance = new showArc(showArcDiv);
    
        // // Î≤ÑÌäº ÌôúÏÑ±Ìôî Í∑úÏπô Ï†ïÏùò
        // defineButtonClassRules([
        //     {
        //         selector: "math-field",
        //         key: "check_target",
        //         test: (el) => {
        //             // correction Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
        //             const correction = el.getAttribute('data-correction');
        //             // correction ÏÜçÏÑ±Ïù¥ ÏóÜÍ±∞ÎÇò Îπà Î∞∞Ïó¥Ïù¥Î©¥ false
        //             return !correction || correction === '[]' ? false : true;
        //         },
        //         setClass: [
        //             { target: ".btnReset", class: "active" },
        //             { target: ".btnCheck", class: "active" }
        //         ]
        //     },
        //     {
        //         selector: ".show_arc",
        //         key: "check_target",
        //         test: (el) => {
        //             // correction Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
        //             const correction = el.getAttribute('data-correction');
        //             // correction ÏÜçÏÑ±Ïù¥ ÏóÜÍ±∞ÎÇò Îπà Î∞∞Ïó¥Ïù¥Î©¥ false
        //             return !correction || correction === '[]' ? false : true;
        //         },
        //         setClass: [
        //             { target: ".btnReset", class: "active" },
        //             { target: ".btnCheck", class: "active" }
        //         ]
        //     }
        // ]);
    
        window.resetCustom = function () {
            const activePage = pagenation.activePage;
            if (activePage) {
                const activeShowArc = activePage.querySelector('.show_arc');
    
                // Î™®Îì† ÏÑ† Ï†úÍ±∞
                const lines = activeShowArc.querySelectorAll('.click-line');
                lines.forEach(line => line.remove());
    
                // Î™®Îì† Ï†ê Ï†úÍ±∞
                const points = activeShowArc.querySelectorAll('.click-point');
                points.forEach(point => point.remove());
    
                // data-correction ÏÜçÏÑ± Ï†úÍ±∞
                activeShowArc.removeAttribute('data-correction');
    
                // data-connection ÏÜçÏÑ± Ï¥àÍ∏∞Ìôî
                activeShowArc.setAttribute('data-connection', JSON.stringify([]));
    
                // Ïù∏Ïä§ÌÑ¥Ïä§Ïùò Ï†ïÎ≥¥ Ï†úÍ±∞
                showArcInstance.reset();
    
                // Î≤ÑÌäº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                window.forceWatchEvaluation();
            }
        }
    
        window.getCustomTargets = function (page) {
            return $(page).find(".show_arc");
        };
    
        let dataAnswers;
        // Ïª§Ïä§ÌÖÄ Ï†ïÎãµ Ï°∞Í±¥
        window.customCheckCondition = function (el) {
            // data-correction ÏÜçÏÑ±Ïù¥ 'true'Ïù¥Î©¥ Ï†ïÎãµ Ï≤òÎ¶¨
            console.log(el);
            const correction = el.getAttribute('data-correction');
            dataAnswers = el.getAttribute('data-single-answer');
            if (correction === 'true') {
                return true;
            }
    
            // data-correction ÏÜçÏÑ±Ïù¥ ÏóÜÍ±∞ÎÇò 'false'Ïù¥Î©¥ Ïò§Îãµ Ï≤òÎ¶¨
            return false;
        };
    
        // Îëê Î≤àÏß∏ Ïò§Îãµ Ïãú
        window.onIncorrectTwiceCustom = function () {
            // alert("üö® Ï†ïÎãµ Í≥µÍ∞úÎê©ÎãàÎã§!");
    
            showArcInstance.reset();
    
            // Ï†ïÎãµ ÏÑ† Í∑∏Î¶¨Í∏∞
            // console.log("dataAnswers", dataAnswers);
            // dataAnswersParsed = JSON.parse(dataAnswers);
    
            const forceClickArr = [1, 6, 6, 11];
            forceClickArr.forEach((value, index) => {
                showArcInstance.forceClick(value);
                // console.log(value);
            });
        };
    // }
});

const colors = ['#F00', '#3B71FE', '#222'];

class showArc {
    constructor(showArcDiv) {
        this.showArcDiv = showArcDiv;
        this.svg = showArcDiv.querySelector('#showArcSvg');
        this.NS = "http://www.w3.org/2000/svg";

        this.svgHeight = Number(this.svg.getAttribute('height'));
        this.svgWidth = Number(this.svg.getAttribute('width'));

        this.barRect = this.svg.querySelector('rect.bar');
        this.barWidth = Number(this.barRect.getAttribute('width'));
        this.barHeight = Number(this.barRect.getAttribute('height'));
        this.barStartX = Number(this.barRect.getAttribute('x'));
        this.barStartY = Number(this.barRect.getAttribute('y'));

        this.sectionPx = this.barWidth / 15;

        // // Í∏∞Î≥∏ ÏÑ§Ï†ï Í∞í Î°úÍ∑∏
        // console.log("this.svgHeight", this.svgHeight);
        // console.log("this.svgWidth", this.svgWidth);
        // console.log("this.barWidth", this.barWidth);
        // console.log("this.barHeight", this.barHeight);
        // console.log("this.barStartX", this.barStartX);
        // console.log("this.barStartY", this.barStartY);

        // // Í≥ÑÏÇ∞ Î°úÍ∑∏
        // console.log("this.barWidth / 15", this.barWidth / 15); // 70

        // ÏÉÅÌÉú Í¥ÄÎ¶¨
        this.state = {
            arcs: [],
        };

        this.selectedPoints = [];
        this.selectedtwoPoints = [];
        this.selectedClickPoints = [];

        this.init();
    };

    init() {
        console.log('init');

        // Ï¥àÍ∏∞ Ï†êÎì§ ÏÉùÏÑ±
        this.createDiameterPoints();
    }

    createDiameterPoints() {
        for (let i = 0; i < 11; i++) {
            const x = this.barStartX + (this.sectionPx * 5) + (i * this.sectionPx);
            const y = this.barStartY;

            const clickArea = document.createElementNS(this.NS, "circle");
            clickArea.setAttribute("cx", x);
            clickArea.setAttribute("cy", y);
            clickArea.setAttribute("r", "16");
            clickArea.setAttribute("class", "diameter-point-area");
            clickArea.setAttribute("data-selected", "false");
            clickArea.setAttribute("data-order", `${i + 1}`);

            const point = document.createElementNS(this.NS, "circle");
            point.setAttribute("cx", x);
            point.setAttribute("cy", y);
            point.setAttribute("r", "16");
            point.setAttribute("class", "diameter-point");
            point.setAttribute("data-selected", "false");

            const handleClick = (e) => {
                e.stopPropagation();

                clickArea.setAttribute("data-selected", "true");
                point.setAttribute("data-selected", "true");

                this.selectedPoints.push({ x, y });
                this.selectedtwoPoints.push({ clickArea, point });

                this.drawPoint(x, y);

                if (this.selectedPoints.length === 2) {
                    const [p1, p2] = this.selectedPoints;

                    const existingLine = this.state.arcs.find(arc => {
                        const match1 = arc.x1 === p1.x && arc.y1 === p1.y && arc.x2 === p2.x && arc.y2 === p2.y;
                        const match2 = arc.x1 === p2.x && arc.y1 === p2.y && arc.x2 === p1.x && arc.y2 === p1.y;
                        return match1 || match2;
                    });

                    if (existingLine) {
                        console.log('Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÏÑ†ÏûÖÎãàÎã§!');

                        this.svg.querySelector(`.diameter-point-area[cx="${p1.x}"][cy="${p1.y}"]`)?.setAttribute('data-selected', 'false');
                        this.svg.querySelector(`.diameter-point[cx="${p1.x}"][cy="${p1.y}"]`)?.setAttribute('data-selected', 'false');
                        this.svg.querySelector(`.diameter-point-area[cx="${p2.x}"][cy="${p2.y}"]`)?.setAttribute('data-selected', 'false');
                        this.svg.querySelector(`.diameter-point[cx="${p2.x}"][cy="${p2.y}"]`)?.setAttribute('data-selected', 'false');

                        for(const arc of this.state.arcs){
                            const equalArc = (
                                arc.x1 === p1.x && arc.x2 === p2.x || 
                                arc.x2 === p1.x && arc.x1 === p2.x
                            );
                            console.log('equalArc', equalArc);
                            if(equalArc){
                                this.svg.removeChild(arc.path);
                                this.state.arcs.pop(arc);
                                console.log(this.state.arcs);
                            }
                        }
                        for (const sCPoint of this.selectedClickPoints) {
                            console.log('sCPoint', sCPoint);
                            console.log('sCPoint parentNode', sCPoint.parentNode);
                            this.svg.removeChild(sCPoint);
                            // this.state.twoPoint.pop(sCPoint);

                            const existingPoints = Array.from(this.svg.getElementsByClassName('click-point'));
                            console.log("existingPoints.length", existingPoints.length)
                            for(const exPoint of existingPoints){
                                const exCx = exPoint.getAttribute("cx");
                                const spCx = sCPoint.getAttribute("cx");
                                if(exCx === spCx) {
                                    console.log('exPoint', exPoint);
                                    if(exPoint) {
                                        this.svg.removeChild(exPoint);
                                    }
                                    break;
                                }
                            }
                        }
                    } else {
                        console.log('Ìò∏ Í∑∏Î¶¨Í∏∞');
                        this.drawArc();
                    }

                    this.selectedPoints = [];
                    this.selectedtwoPoints = [];
                    this.selectedClickPoints = [];
                }

                console.log('this.state', this.state);
                this.update();
            };

            clickArea.addEventListener('click', handleClick);
            point.addEventListener('click', handleClick);

            this.svg.appendChild(clickArea);
            this.svg.appendChild(point);
        }
    }

    drawPoint(x, y) {
        const existingPoints = Array.from(this.svg.getElementsByClassName('click-point'));

        const point = document.createElementNS(this.NS, "circle");
        point.setAttribute("cx", x);
        point.setAttribute("cy", y);
        point.setAttribute("r", "6");
        point.setAttribute("class", "click-point");
        // point.setAttribute('data-id', Math.random());

        this.svg.appendChild(point);

        this.selectedClickPoints.push(point);
        console.log('this.selectedClickPoints', this.selectedClickPoints);

        // if(this.selectedClickPoints.length === 2){
        //     this.selectedClickPoints = [];
        //     console.log('this.selectedClickPoints clear', this.selectedClickPoints);
        // }
    }

    // remove2point(twoPoint) {
    //     // Îëê Ï†ê ÏßÄÏö∞Í∏∞
    //     // Ï°¥Ïû¨ÌïòÎäî ÎùºÏù∏Í≥º Ï†êÎì§
    //     const existingPoints = Array.from(this.svg.getElementsByClassName('click-point'));
    //     // Îëê Ï†ê ÏÇ≠Ï†ú
    //     for (const point of twoPoint) {
    //         const { x, y } = point;
    
    //         // 1. Ï†ê ÏÇ≠Ï†ú
    //         for (const exPoint of existingPoints) {
    //             const exCX = parseFloat(exPoint.getAttribute('cx'));
    //             const exCY = parseFloat(exPoint.getAttribute('cy'));
    
    //             if (exCX === x && exCY === y) {
    //                 // Ï†ê ÏÇ≠Ï†ú
    //                 this.svg.removeChild(exPoint);
    //             }
    //         }
    //     }
    // }

    // removeArc() {
    //     const existingArcs = Array.from(this.svg.getElementsByClassName('click-line'));

    //     for (const point of this.selectedPoints) {
    //         const { x, y } = point;

    //         for (const arc of existingArcs) {
    //             const x1 = parseFloat(arc.getAttribute('data-x1'));
    //             const y1 = parseFloat(arc.getAttribute('data-y1'));
    //             const x2 = parseFloat(arc.getAttribute('data-x2'));
    //             const y2 = parseFloat(arc.getAttribute('data-y2'));

    //             const isConnected = (x1 === x && y1 === y) || (x2 === x && y2 === y);

    //             if (isConnected) {
    //                 if (this.svg.contains(arc)) {
    //                     this.svg.removeChild(arc);
    //                 }
    //                 this.state.arcs = this.state.arcs.filter(a =>
    //                     !((a.x1 === x1 && a.y1 === y1 && a.x2 === x2 && a.y2 === y2) ||
    //                         (a.x1 === x2 && a.y1 === y2 && a.x2 === x1 && a.y2 === y1))
    //                 );
    //             }
    //         }
    //     }
    // }

    drawArc() {
        const [p1, p2] = this.selectedPoints;

        const cx1 = p1.x + (p2.x - p1.x) * 0.25;
        const cy1 = p1.y - (Math.abs(p2.x - p1.x) / 5.6) - 16;
        const cx2 = p1.x + (p2.x - p1.x) * 0.75;
        const cy2 = p2.y - (Math.abs(p2.x - p1.x) / 5.6) - 16;

        const path = document.createElementNS(this.NS, "path");
        const d = `M${p1.x} ${p1.y} C${cx1} ${cy1} ${cx2} ${cy2} ${p2.x} ${p2.y}`;

        path.setAttribute("d", d);
        path.setAttribute("stroke", colors[this.state.arcs.length % colors.length]);
        path.setAttribute("stroke-width", "2");
        path.setAttribute("stroke-dasharray", "4 4");
        path.setAttribute("fill", "transparent");
        path.setAttribute("class", "click-line");
        path.setAttribute("data-x1", p1.x);
        path.setAttribute("data-x2", p2.x);
        path.setAttribute("data-y1", p1.y);
        path.setAttribute("data-y2", p2.y);

        this.svg.appendChild(path);

        this.state.arcs.push({ x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, area: Math.round(Math.abs(p2.x - p1.x) / this.sectionPx), path: path});
        console.log('this.state.arcs', this.state.arcs);
    }

    update() {
        this.showArcDiv.removeAttribute('data-correction');
        this.showArcDiv.setAttribute('data-connection', JSON.stringify([]));
        // Î≤ÑÌäº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        window.forceWatchEvaluation();

        const areas = [];
        for(const arc of this.state.arcs) {
            areas.push(arc.area);
        }

        // connection Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
        this.showArcDiv.setAttribute('data-connection', JSON.stringify(areas));

        // correction Îç∞Ïù¥ÌÑ∞ Ï≤¥ÌÅ¨
        const answerData = this.showArcDiv.getAttribute('data-single-answer');

        console.log('ÌòÑÏû¨ ÏòÅÏó≠:', areas);
        console.log('Ï†ïÎãµ Îç∞Ïù¥ÌÑ∞:', answerData);

        if (answerData) {
            try {
                // data-single-answer Í∞íÏùÑ JSONÏúºÎ°ú ÌååÏã±
                const answers = JSON.parse(answerData);

                console.log('ÌååÏã±Îêú Ï†ïÎãµ:', answers);

                // Î∞∞Ïó¥ Í∏∏Ïù¥Í∞Ä Îã§Î•¥Î©¥ false
                if (areas.length !== answers.length) {
                    console.log('Î∞∞Ïó¥ Í∏∏Ïù¥ Î∂àÏùºÏπò:', areas.length, answers.length);
                    this.showArcDiv.setAttribute('data-correction', 'false');
                    // Î≤ÑÌäº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                    window.forceWatchEvaluation();
                    return;
                }

                // Í∞íÎßå ÎπÑÍµêÌïòÎ†§Î©¥ Îëê Î∞∞Ïó¥ÏùÑ Ï†ïÎ†¨ ÌõÑ ÎπÑÍµê
                const sortedPercentages = [...areas].sort((a, b) => a - b);
                const sortedAnswers = [...answers].sort((a, b) => a - b);

                // Î∞∞Ïó¥ Í∞í ÎπÑÍµê
                let isCorrect = sortedPercentages.every((val, index) => parseInt(val) === parseInt(sortedAnswers[index]));

                console.log('Ï†ïÎãµ Ïó¨Î∂Ä:', isCorrect);
                if (isCorrect) {
                    this.showArcDiv.setAttribute('data-correction', 'true');
                } else {
                    this.showArcDiv.setAttribute('data-correction', 'false');
                }
                // Î≤ÑÌäº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                window.forceWatchEvaluation();
            } catch (e) {
                console.error('JSON ÌååÏã± ÏóêÎü¨:', e);
                this.showArcDiv.setAttribute('data-correction', 'false');
                // Î≤ÑÌäº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                window.forceWatchEvaluation();
            }
        }
    }

    reset() {
        // Î™®Îì† ÏÑ†, Ï†ê, ÌÖçÏä§Ìä∏ Ï†úÍ±∞
        const arcs = this.svg.getElementsByClassName('click-line');
        const points = this.svg.getElementsByClassName('click-point');

        while (arcs.length > 0) arcs[0].remove();
        while (points.length > 0) points[0].remove();

        // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        this.state.arcs = [];

        // data-selected=true Ï†úÍ±∞
        const selectedElements = this.svg.querySelectorAll('[data-selected="true"]');
        selectedElements.forEach(el => {
            el.setAttribute('data-selected', 'false');
        });

        // data-correction ÏÜçÏÑ± Ï†úÍ±∞
        this.showArcDiv.removeAttribute('data-correction');

        console.log('showArcInstans Î¶¨ÏÖã Îê®');
    }

    // ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ Î∞úÏÉù ÏãúÌÇ§Í∏∞
    forceClick(dataOrder) {
        // ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ Î∞úÏÉùÏãúÏºú ÏÑ† Ï∂îÍ∞Ä
        const clickPoints = document.querySelectorAll(`circle[data-order="${dataOrder}"]`);
        if (clickPoints) {
            clickPoints.forEach((value) => {
                // 'click' Ïù¥Î≤§Ìä∏Î•º Í∞ïÏ†úÎ°ú Î∞úÏÉùÏãúÌÇ¥
                const clickEvent = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: window
                });
                value.dispatchEvent(clickEvent);
            });
        } else {
            console.warn(`circle[data-order="${dataOrder}"]Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`);
        }
    }
}